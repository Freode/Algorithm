// 실버 1 - 16456번 : 하와와 대학생쨩 하와이로 가는 거시와요~
// 작성자 : free4760(jeonghoe22)

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 섬 n개 (1~50'000)

// 첫 번째 섬에서 시작 (반드시 +1로 시작)
// 1. 어떤 섬을 보고 바로 다음 섬으로 갈 수 있음
// 2. 어떤 섬을 보고 한 섬을 건너 뛰고 그 다음 섬으로 이동 가능
// 3. 어떤 섬을 보고 그 이전 섬으로 이동 가능

// x+1, x+2, x-1 이동 가능

// 한 번 갔던 섬은 다시 이동하지 않음.
// n개 섬 모두 방문해야 함.

// n개의 섬으로 구성된 열도 -> 여행하는 방법 구하기

// -1은 항상 2와 있어야 함.
// 1. 2(2) -1(1) 2(3)
// 2. 마지막 -> 2(n) -1(n-1)
// 3. 단순 +1

// 1 -> 1

// 1. +1
// 2. +2
// 3. -1

// -> 1. +1 f(n-1)
// -> 2. +2 f(n-1) 1.2. 둘 다 포함
// -> 3. +2 -1 혼합 -> 2 -1 이 연속으로 배치 불가능

// 중복 방문 x
// 첫 번째 섬에서 시작

// 2 -> 1
// 1

// 3 -> 2
// 1 1
// 2 -1

// 4 -> 3
// 1 1 1
// 2 -1 2 f(3)
// 1 2 -1 f(2)

// 5 -> 4
// 1 1 1 1
// 2 -1 2 1
// 1 2 -1 2 f(4)
// 1 1 2 -1 f(3)-1
// 2 -1 2 1(중복)

// 6 -> 6
// 1 1 1 1 1
// 2 -1 2 1 1
// 1 2 -1 2 1
// 1 1 2 -1 2 f(5)
// 1 1 1 2 -1
// 2 -1 2 2 -1 f(4)-1
// 1 2 -1 2 1 (중복)

// 7 -> 9 
// 1 1 1 1 1 1
// 2 -1 2 1 1 1
// 1 2 -1 2 1 1
// 1 1 2 -1 2 1
// 1 1 1 2 -1 2
// 2 -1 2 2 -1 2 f(6)
// 1 1 1 1 2 -1
// 2 -1 2 1 2 -1 
// 1 2 -1 2 2 -1 f(5)-1
// 1 1 2 -1 2 1 (중복)

// 8 -> 13
// 1 1 1 1 1 1 1
// 2 -1 2 1 1 1 1
// 1 2 -1 2 1 1 1
// 1 1 2 -1 2 1 1
// 1 1 1 2 -1 2 1
// 2 -1 2 2 -1 2 1
// 1 1 1 1 2 -1 2
// 2 -1 2 1 2 -1 2
// 1 2 -1 2 2 -1 2

// 1 1 1 1 1 2 -1
// 2 -1 2 1 1 2 -1
// 1 2 -1 2 1 2 -1
// 1 1 2 -1 2 2 -1
// 1 1 1 2 -1 2 -1 (불가능)
// 2 -1 2 2 -1 2 -1 (불가능)


// f(n) = f(n-1) + (f(n-2) - f(n-2)의 마지막에 (2,-1)인 경우)
// f(n-1)에 단순 +1와 +2 포함
// f(n-2)에 +2 -1 경우 포함. (단, +2, -1이 연속으로 배치 불가능)
// 음수인 경우 양수로 변경

// 10억9 로 나머지 연산하므로 두 수를 더해도 int 범위 내

const int DIV = 1'000'000'009;

struct Num
{
    int total = 0;
    int mix = 0;
};

int main()
{
    // 입출력 최적화
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    // 섬의 개수
    int n;
    cin >> n;

    vector<Num> nums(n+1);
    nums[1].total = 1;
    
    for(int i = 2; i <= n; i++)
    {
        nums[i].mix = (nums[i-2].total - nums[i-2].mix) % DIV;
        if(nums[i].mix < 0)
          nums[i].mix += DIV;
          
        nums[i].total = (nums[i-1].total + nums[i].mix) % DIV;
        if(nums[i].total < 0)
            nums[i].total += DIV;
    }

    cout << nums[n].total << "\n";
}