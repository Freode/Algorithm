// 골드 5 - 2294번 : 동전 2
// 작성자 : free4760

#include <iostream>
#include <vector>

using namespace std;

// f(0) = 0
// 해당 값을 구성할 수 있는 최소 동전 개수를 조사할 때, 동전 종류를 오름차순으로 하나씩 추가
// 새로운 동전 종류가 하나 추가되었을 때, 해당 동전 가치보다 작은 값을 구성하는 동전 최소 개수는 모두 고정
// f(n) = min(f(n-현재 동전 가치) + 1, f(n))
// f(n-현재 동전 가치) + 1은 새롭게 추가된 동전을 사용한 것이므로 동전 사용 개수를 1개 증가

// 1로 조합 - 첫 번째
// 1,5로 조합 - f(4) 이하는 고정
// 1,5,12로 조합 - f(11) 이하는 고정

// f(12) = min(f(12-12) + 1, f(12))
// f(12) = min(1, 3) -> 1로 변경

// -1은 입력되는 동전 가치를 넘은 10001로 표시
// min으로 -1가 나올 때, 처리해야하는 조건문 2개를 추가하지 않아도 됨.
// 예) min(a,b)가 있을 때, a가 -1이면, b 선택하고 b가 -1이면, a를 선택해야 함.

// n = 3, k = 15, 동전 가치 2,5,12
//   0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
// 2:0 / 1 / 2 / 3 / 4 /  5  /  6  /  7  /
// 5:0 / 1 / 2 1 3 2 4 3  2  4  3  5  4  3
//12:0 / 1 / 2 1 3 2 4 3  2  4  1  5  2  3

int main()
{
	// 입출력 최적화
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);


	// 입력
	int n, k;
	cin >> n >> k;

	// 동전 가치 입력
	vector<int> coins(n);
	for (int& coin : coins)
	{
		cin >> coin;
	}

	// f(n)에서 최소 동전 사용 개수를 구하기
	vector<int> cases(k + 1, -1);
	
	// 0번째는 0
	cases[0] = 0;

	// 1번째 줄 초기화
	for (int i = 1; i < k + 1; i++)
	{
		cases[i] = (i % coins[0] == 0) ? i / coins[0] : 10001;
	}

	// 동전 종류를 하나씩 추가해서 검사
	for (int i = 1; i < n; i++)
	{
		// 추가된 동전 종류의 가치보다 낮은 f(n)은 모두 무시
		// f(n) = min(f(n-현재 동전 가치) + 1, f(n))
		for (int j = coins[i]; j < k + 1; j++)
		{
			cases[j] = min(cases[j - coins[i]] + 1, cases[j]);
		}
	}

	if(cases[k])

	// 출력문
	cout << ((cases[k] == 10001) ? -1 : cases[k]) << "\n";

}